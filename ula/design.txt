-- Code your design here
library IEEE;
use IEEE.std_logic_1164.all;

entity porta_and is
    port(
        x, y : in bit;
        z    : out bit
    );
end porta_and;

architecture main of porta_and is
begin
    z <= x and y;
end main;

entity inversora is
	port(
    	x : in bit;
        z : out bit
    );
end inversora;

architecture main of inversora is
begin
	z <= NOT x;
end main;

entity somador is 
	port(
    	cin, x, y	:	in bit;
        cout, z	:	out bit
    );
end somador;

architecture main of somador is 
begin
	z <= (cin xor y) xor x;
    cout <= (cin and x) or (cin and y) or (x and y);
end main;

entity deslocador_esquerda8bits is
    port(
        entrada   : in  bit_vector(7 downto 0);  
        bits      : in  integer range 0 to 7;   
        saida     : out bit_vector(7 downto 0)   
    );
end deslocador_esquerda8bits;

architecture main of deslocador_esquerda8bits is
begin
    process(entrada, bits)
    begin
        case bits is
            when 0 => saida <= entrada;
            when 1 => saida <= entrada(6 downto 0) & '0';
            when 2 => saida <= entrada(5 downto 0) & "00";
            when 3 => saida <= entrada(4 downto 0) & "000";
            when 4 => saida <= entrada(3 downto 0) & "0000";
            when 5 => saida <= entrada(2 downto 0) & "00000";
            when 6 => saida <= entrada(1 downto 0) & "000000";
            when 7 => saida <= entrada(0) & "0000000";
        end case;
    end process;
end main;

entity somador8bits is
	 port(
        a, b : in bit_vector(7 downto 0);
        resultado : out bit_vector(7 downto 0);
        carry_out : out bit
    );
end somador8bits;

architecture main of somador8bits is

component somador is
    port(
        cin, x, y : in bit;
        cout, z   : out bit
    );
end component;

signal carry : bit_vector(7 downto 0);

begin

    FA0: somador port map(
        cin => '0',
        x => a(0),
        y => b(0),
        cout => carry(0),
        z => resultado(0)
    );
    
    FA1: somador port map(
        cin => carry(0),
        x => a(1),
        y => b(1), 
        cout => carry(1),
        z => resultado(1)
    );
    
    FA2: somador port map(
        cin => carry(1),
        x => a(2),
        y => b(2), 
        cout => carry(2),
        z => resultado(2)
    );
    
    FA3: somador port map(
        cin => carry(2),
        x => a(3),
        y => b(3), 
        cout => carry(3),
        z => resultado(3)
    );
    
    FA4: somador port map(
        cin => carry(3),
        x => a(4),
        y => b(4), 
        cout => carry(4),
        z => resultado(4)
    );
    
    FA5: somador port map(
        cin => carry(4),
        x => a(5),
        y => b(5), 
        cout => carry(5),
        z => resultado(5)
    );
    
    FA6: somador port map(
        cin => carry(5),
        x => a(6),
        y => b(6), 
        cout => carry(6),
        z => resultado(6)
    );
    
    FA7: somador port map(
        cin => carry(6),
        x => a(7),
        y => b(7),
        cout => carry(7),
        z => resultado(7)
    );
    
    carry_out <= carry(7);
    
end main;

entity subtrator8bits is
	 port(
        c, d : in bit_vector(7 downto 0);
        resultado_sub : out bit_vector(7 downto 0);
        carry_out_sub : out bit
    );
end subtrator8bits;

architecture main of subtrator8bits is

component inversora is
	port(
    	x : in bit;
        z : out bit
    );
end component;

component somador8bits is
   port(
        a, b : in bit_vector(7 downto 0);
        resultado : out bit_vector(7 downto 0);
        carry_out : out bit
    );
end component;

signal complemento_de_um : bit_vector(7 downto 0); 
signal complemento_de_dois : bit_vector(7 downto 0);

begin

INV0: inversora port map(
    x => d(0),
    z => complemento_de_um(0)
);

INV1: inversora port map(
    x => d(1),
    z => complemento_de_um(1)
);

INV2: inversora port map(
    x => d(2),
    z => complemento_de_um(2)
);

INV3: inversora port map(
    x => d(3),
    z => complemento_de_um(3)
);

INV4: inversora port map(
    x => d(4),
    z => complemento_de_um(4)
);

INV5: inversora port map(
    x => d(5),
    z => complemento_de_um(5)
);

INV6: inversora port map(
    x => d(6),
    z => complemento_de_um(6)
);

INV7: inversora port map(
    x => d(7),
    z => complemento_de_um(7)
);
    
CLP2: somador8bits port map(
	a => complemento_de_um,
    b => "00000001",
    resultado => complemento_de_dois
);

SomadorFinal: somador8bits port map(
	a => c,
    b => complemento_de_dois,
    resultado => resultado_sub,
    carry_out => carry_out_sub
);
    
end main;

-- MULTIPLICADOR COM SHIFTING
entity multiplicador8bits is
    port(
        a, b : in bit_vector(7 downto 0);
        resultado : out bit_vector(7 downto 0);
        overflow : out bit
    );
end multiplicador8bits;

architecture main of multiplicador8bits is
    
    component deslocador_esquerda8bits is
        port(
            entrada   : in  bit_vector(7 downto 0);
            bits      : in  integer range 0 to 7;
            saida     : out bit_vector(7 downto 0)
        );
    end component;
    
    component somador8bits is
        port( 
            a, b : in bit_vector(7 downto 0);
            resultado : out bit_vector(7 downto 0);
            carry_out : out bit 
        );
    end component;
    
    -- Sinais para cada valor deslocado
    signal desloc0, desloc1, desloc2, desloc3 : bit_vector(7 downto 0);
    signal desloc4, desloc5, desloc6, desloc7 : bit_vector(7 downto 0);
    
    -- Sinais para as entradas dos somadores (com seleção baseada nos bits de b)
    signal entrada_som2, entrada_som3, entrada_som4 : bit_vector(7 downto 0);
    signal entrada_som5, entrada_som6, entrada_som7 : bit_vector(7 downto 0);
    
    -- Sinais para somas intermediárias
    signal soma1, soma2, soma3, soma4 : bit_vector(7 downto 0);
    signal soma5, soma6 : bit_vector(7 downto 0);
    signal carry1, carry2, carry3, carry4 : bit;
    signal carry5, carry6 : bit;
    
begin
    
    -- Gera todos os deslocamentos possíveis
    DESLOCAMENTO0: deslocador_esquerda8bits port map(a, 0, desloc0); -- a * 1
    DESLOCAMENTO1: deslocador_esquerda8bits port map(a, 1, desloc1); -- a * 2
    DESLOCAMENTO2: deslocador_esquerda8bits port map(a, 2, desloc2); -- a * 4
    DESLOCAMENTO3: deslocador_esquerda8bits port map(a, 3, desloc3); -- a * 8
    DESLOCAMENTO4: deslocador_esquerda8bits port map(a, 4, desloc4); -- a * 16
    DESLOCAMENTO5: deslocador_esquerda8bits port map(a, 5, desloc5); -- a * 32
    DESLOCAMENTO6: deslocador_esquerda8bits port map(a, 6, desloc6); -- a * 64
    DESLOCAMENTO7: deslocador_esquerda8bits port map(a, 7, desloc7); -- a * 128
    
    -- Seleção das entradas baseadas nos bits de b
    entrada_som2 <= desloc1 when b(1) = '1' else "00000000";
    entrada_som3 <= desloc2 when b(2) = '1' else "00000000";
    entrada_som4 <= desloc3 when b(3) = '1' else "00000000";
    entrada_som5 <= desloc4 when b(4) = '1' else "00000000";
    entrada_som6 <= desloc5 when b(5) = '1' else "00000000";
    entrada_som7 <= desloc6 when b(6) = '1' else "00000000";
    
    -- Primeira soma: Bit 0
    soma1 <= desloc0 when b(0) = '1' else "00000000";
    carry1 <= '0';
    
    -- Segunda soma: Bit 1
    SOM2: somador8bits port map(
        a => soma1,
        b => entrada_som2,
        resultado => soma2,
        carry_out => carry2
    );
    
    -- Terceira soma: Bit 2
    SOM3: somador8bits port map(
        a => soma2,
        b => entrada_som3,
        resultado => soma3,
        carry_out => carry3
    );
    
    -- Quarta soma: Bit 3
    SOM4: somador8bits port map(
        a => soma3,
        b => entrada_som4,
        resultado => soma4,
        carry_out => carry4
    );
    
    -- Quinta soma: Bit 4
    SOM5: somador8bits port map(
        a => soma4,
        b => entrada_som5,
        resultado => soma5,
        carry_out => carry5
    );
    
    -- Sexta soma: Bit 5
    SOM6: somador8bits port map(
        a => soma5,
        b => entrada_som6,
        resultado => soma6,
        carry_out => carry6
    );
    
    -- Sétima soma: Bit 6
    SOM7: somador8bits port map(
        a => soma6,
        b => entrada_som7,
        resultado => resultado,
        carry_out => overflow
    );
    
    -- O bit 7 não é somado para evitar overflow
    
end main;
