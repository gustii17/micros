-- Code your design here
library IEEE;
use IEEE.std_logic_1164.all;


entity porta_and is
    port(
        x, y : in bit;
        z    : out bit
    );
end porta_and;



architecture main of porta_and is
begin
    z <= x and y;
end main;


entity inversora is
	port(
    	x : in bit;
        z : out bit
    );
end inversora;

architecture main of inversora is
begin
	z <= NOT x;
end main;



entity somador is 
	port(
    	cin, x, y	:	in bit;
        cout, z	:	out bit
    );
end somador;

architecture main of somador is 
begin
	z <= (cin xor y) xor x;
    cout <= (cin and x) or (cin and y) or (x and y);
end main;




entity somador8bits is
	 port(
        a, b : in bit_vector(7 downto 0);
        resultado : out bit_vector(7 downto 0);
        carry_out : out bit
    );
end somador8bits;



architecture main of somador8bits is

component somador is
    port(
        cin, x, y : in bit;
        cout, z   : out bit
    );
end component;

signal carry : bit_vector(7 downto 0); --Este vetor de sinais representará os carries de transição

begin

 -- Primeiro estágio (bit 0)
    FA0: somador port map(
        cin => '0',           -- Carry-in inicial
        x => a(0),
        y => b(0),
        cout => carry(0),     -- Carry para próximo estágio
        z => resultado(0)
    );
    
    -- Estágios intermediários (bits 1 a 6)
    FA1: somador port map(
        cin => carry(0),
        x => a(1),
        y => b(1), 
        cout => carry(1),
        z => resultado(1)
    );
    
     FA2: somador port map(
        cin => carry(1),
        x => a(2),
        y => b(2), 
        cout => carry(2),
        z => resultado(2)
    );
    
    FA3: somador port map(
        cin => carry(2),
        x => a(3),
        y => b(3), 
        cout => carry(3),
        z => resultado(3)
    );
    
     FA4: somador port map(
        cin => carry(3),
        x => a(4),
        y => b(4), 
        cout => carry(4),
        z => resultado(4)
    );
    
    FA5: somador port map(
        cin => carry(4),
        x => a(5),
        y => b(5), 
        cout => carry(5),
        z => resultado(5)
    );
    
    FA6: somador port map(
        cin => carry(5),
        x => a(6),
        y => b(6), 
        cout => carry(6),
        z => resultado(6)
    );
    
    FA7: somador port map(
        cin => carry(6),
        x => a(7),
        y => b(7),
        cout => carry(7),
        z => resultado(7)
    );
    
    carry_out <= carry(7);  -- Carry final
    
end main;



entity subtrator8bits is
	 port(
        c, d : in bit_vector(7 downto 0);
        resultado_sub : out bit_vector(7 downto 0);
        carry_out_sub : out bit
    );
end subtrator8bits;






architecture main of subtrator8bits is

component inversora is
	port(
    	x : in bit;
        z : out bit
    );
end component;

component somador8bits is
   port(
        a, b : in bit_vector(7 downto 0);
        resultado : out bit_vector(7 downto 0);
        carry_out : out bit
    );
end component;

signal complemento_de_um : bit_vector(7 downto 0); 

signal complemento_de_dois : bit_vector(7 downto 0);

begin

INV0: inversora port map(
    x => d(0),
    z => complemento_de_um(0)
);

INV1: inversora port map(
    x => d(1),
    z => complemento_de_um(1)
);

INV2: inversora port map(
    x => d(2),
    z => complemento_de_um(2)
);

INV3: inversora port map(
    x => d(3),
    z => complemento_de_um(3)
);

INV4: inversora port map(
    x => d(4),
    z => complemento_de_um(4)
);

INV5: inversora port map(
    x => d(5),
    z => complemento_de_um(5)
);

INV6: inversora port map(
    x => d(6),
    z => complemento_de_um(6)
);

INV7: inversora port map(
    x => d(7),
    z => complemento_de_um(7)
);
    
CLP2: somador8bits port map(
	a => complemento_de_um,
    b => "00000001",
    
    resultado => complemento_de_dois
    --carry_out => carry_out_sub;
);

SomadorFinal: somador8bits port map(
	a => c,
    b => complemento_de_dois,
    
    resultado => resultado_sub,
    carry_out => carry_out_sub
);
    
end main;


entity multiplicador8bits is
    port(
        a, b : in bit_vector(7 downto 0);
        resultado : out bit_vector(7 downto 0);
        overflow : out bit
    );
end multiplicador8bits;

architecture main of multiplicador8bits is
    
    component porta_and is
        port( x, y : in bit; z : out bit );
    end component;
    
    component somador8bits is
        port( a, b : in bit_vector(7 downto 0);
              resultado : out bit_vector(7 downto 0);
              carry_out : out bit );
    end component;
    
    -- Produtos parciais: 8 linhas de 8 bits cada
    type matriz_produtos is array (0 to 7) of bit_vector(7 downto 0);
    signal produtos : matriz_produtos;
    
    -- Sinais para soma em árvore
    signal soma1, soma2, soma3, soma4 : bit_vector(7 downto 0);
    signal soma5, soma6, soma7 : bit_vector(7 downto 0);
    signal carry1, carry2, carry3, carry4 : bit;
    signal carry5, carry6, carry7 : bit;
    
begin
    
    -- Gera os 8 produtos parciais (cada linha deslocada)
    gen_produtos: for i in 0 to 7 generate
        gen_bits: for j in 0 to 7 generate
            -- Cada produto parcial é AND entre a(j) e b(i)
            AND_IJ: porta_and port map(
                x => a(j),
                y => b(i),
                z => produtos(i)(j)
            );
        end generate gen_bits;
    end generate gen_produtos;
    
    -- ARVORE DE SOMAS 
    
    -- Camada 1: Soma produtos 0 e 1 (com deslocamento)
    SOM1: somador8bits port map(
        a => produtos(0),                                   -- Produto 0
        b(0) => '0',                                        -- Desloca produto 1
        b(1) => produtos(1)(0),
        b(2) => produtos(1)(1),
        b(3) => produtos(1)(2),
        b(4) => produtos(1)(3),
        b(5) => produtos(1)(4),
        b(6) => produtos(1)(5),
        b(7) => produtos(1)(6),
        resultado => soma1,
        carry_out => carry1
    );
    
    -- Camada 2: Soma resultado anterior com produto 2 (deslocado +2)
    SOM2: somador8bits port map(
        a => soma1,
        b(0) => '0',
        b(1) => '0',
        b(2) => produtos(2)(0),
        b(3) => produtos(2)(1),
        b(4) => produtos(2)(2),
        b(5) => produtos(2)(3),
        b(6) => produtos(2)(4),
        b(7) => produtos(2)(5),
        resultado => soma2,
        carry_out => carry2
    );
    
    -- Camada 3: Soma com produto 3 (deslocado +3)
    SOM3: somador8bits port map(
        a => soma2,
        b(0) => '0',
        b(1) => '0',
        b(2) => '0',
        b(3) => produtos(3)(0),
        b(4) => produtos(3)(1),
        b(5) => produtos(3)(2),
        b(6) => produtos(3)(3),
        b(7) => produtos(3)(4),
        resultado => soma3,
        carry_out => carry3
    );
    
    -- Camada 4: Soma com produto 4 (deslocado +4)
    SOM4: somador8bits port map(
        a => soma3,
        b(0) => '0',
        b(1) => '0',
        b(2) => '0',
        b(3) => '0',
        b(4) => produtos(4)(0),
        b(5) => produtos(4)(1),
        b(6) => produtos(4)(2),
        b(7) => produtos(4)(3),
        resultado => soma4,
        carry_out => carry4
    );
    
    -- Camada 5: Soma com produto 5 (deslocado +5)
    SOM5: somador8bits port map(
        a => soma4,
        b(0) => '0',
        b(1) => '0',
        b(2) => '0',
        b(3) => '0',
        b(4) => '0',
        b(5) => produtos(5)(0),
        b(6) => produtos(5)(1),
        b(7) => produtos(5)(2),
        resultado => soma5,
        carry_out => carry5
    );
    
    -- Camada 6: Soma com produto 6 (deslocado +6)
    SOM6: somador8bits port map(
        a => soma5,
        b(0) => '0',
        b(1) => '0',
        b(2) => '0',
        b(3) => '0',
        b(4) => '0',
        b(5) => '0',
        b(6) => produtos(6)(0),
        b(7) => produtos(6)(1),
        resultado => soma6,
        carry_out => carry6
    );
    
    -- Camada 7: Soma com produto 7 (deslocado +7)
    SOM7: somador8bits port map(
        a => soma6,
        b(0) => '0',
        b(1) => '0',
        b(2) => '0',
        b(3) => '0',
        b(4) => '0',
        b(5) => '0',
        b(6) => '0',
        b(7) => produtos(7)(0),
        resultado => soma7,
        carry_out => carry7
    );
    
    -- Detecção de overflow e resultado final
    overflow <= carry1 or carry2 or carry3 or carry4 or carry5 or carry6 or carry7;
    resultado <= soma7;
    
end main;




    	
